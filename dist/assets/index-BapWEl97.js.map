{"version":3,"file":"index-BapWEl97.js","sources":["../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/utils/rlp-decode.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/utils/rlp-encode.js","../../node_modules/@web3auth/ethereum-provider/node_modules/@noble/hashes/esm/sha512.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/crypto/crypto-browser.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/crypto/sha2.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/constants/addresses.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/address/address.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/transaction/accesslist.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/transaction/address.js","../../node_modules/@web3auth/ethereum-provider/node_modules/ethers/lib.esm/transaction/transaction.js"],"sourcesContent":["//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map","//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { getBytes } from \"./data.js\";\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call(getBytes(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */\nexport function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\n//# sourceMappingURL=rlp-encode.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/* Browser Crypto Shims */\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport function createHash(algo) {\n    switch (algo) {\n        case \"sha256\": return sha256.create();\n        case \"sha512\": return sha512.create();\n    }\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexport function createHmac(_algo, key) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return hmac.create(algo, key);\n}\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });\n}\nexport function randomBytes(length) {\n    assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n//# sourceMappingURL=crypto-browser.js.map","import { createHash } from \"./crypto.js\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nconst _sha256 = function (data) {\n    return createHash(\"sha256\").update(data).digest();\n};\nconst _sha512 = function (data) {\n    return createHash(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nexport function sha256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function () { locked256 = true; };\nsha256.register = function (func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */\nexport function sha512(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function () { locked512 = true; };\nsha512.register = function (func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256);\n//# sourceMappingURL=sha2.js.map","/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nexport const ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map","import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map","import { getAddress } from \"../address/index.js\";\nimport { assertArgument, isHexString } from \"../utils/index.js\";\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            assertArgument(isHexString(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nexport function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            assertArgument(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    assertArgument(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n//# sourceMappingURL=accesslist.js.map","import { getAddress } from \"../address/index.js\";\nimport { keccak256, SigningKey } from \"../crypto/index.js\";\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nexport function computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nexport function recoverAddress(digest, signature) {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}\n//# sourceMappingURL=address.js.map","import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) {\n        versioned = \"0\" + versioned;\n    }\n    versioned += sha256(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return accessListify(value);\n    }\n    catch (error) {\n        assertArgument(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatHashes(value, param) {\n    assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = decodeRlp(data);\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: hexlify(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n        //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return encodeRlp(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n    let fields = decodeRlp(getBytes(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n        fields = fields[0];\n    }\n    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", hexlify(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return concat([\n                \"0x03\",\n                encodeRlp([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n        }\n    }\n    return concat([\"0x03\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : getAddress(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = getNumber(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = getBigInt(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : getBigInt(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : getBigInt(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = hexlify(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = getBigInt(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = getBigInt(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : accessListify(value);\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : getBigInt(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b) => Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n            if (isBytesLike(blob)) {\n                assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = getBytes(blob);\n                assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: hexlify(data),\n                    commitment: hexlify(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n            else {\n                const commit = hexlify(blob.commitment);\n                blobs.push({\n                    data: hexlify(blob.data),\n                    commitment: commit,\n                    proof: hexlify(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() { return this.#kzg; }\n    set kzg(kzg) {\n        this.#kzg = kzg;\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#blobs = null;\n        this.#kzg = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return keccak256(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        const sig = signed ? this.signature : null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = getBytes(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map"],"names":["hexlifyByte","value","result","unarrayifyInteger","data","offset","length","i","_decodeChildren","childOffset","decoded","_decode","assert","checkOffset","lengthLength","hexlify","decodeRlp","_data","getBytes","assertArgument","arrayifyInteger","_encode","object","payload","child","nibbles","encodeRlp","v","SHA512_Kh","SHA512_Kl","u64","n","SHA512_W_H","SHA512_W_L","SHA512","SHA2","Ah","Al","Bh","Bl","Ch","Cl","Dh","Dl","Eh","El","Fh","Fl","Gh","Gl","Hh","Hl","view","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","sha512","wrapConstructor","getGlobal","global","anyGlobal","createHash","algo","sha256","_sha256","__sha256","locked256","func","ZeroAddress","BN_0","BN_36","getChecksumAddress","address","chars","expanded","hashed","keccak256","ibanLookup","safeDigits","ibanChecksum","c","block","checksum","Base36","key","fromBase36","getAddress","accessSetify","addr","storageKeys","storageKey","index","isHexString","accessListify","set","accum","a","b","computeAddress","pubkey","SigningKey","recoverAddress","digest","signature","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","BLOB_SIZE","getVersionedHash","version","hash","versioned","handleAddress","handleAccessList","param","error","handleNumber","_value","getNumber","handleUint","getBigInt","formatNumber","name","toBeArray","formatAccessList","formatHashes","_parseLegacy","fields","tx","s","chainId","Signature","zeroPadValue","_serializeLegacy","sig","legacy","_parseEipSignature","yParity","r","_parseEip1559","_serializeEip1559","concat","_parseEip2930","_serializeEip2930","_parseEip4844","typeName","blobs","fBlobs","fCommits","fProofs","_serializeEip4844","_Transaction","__privateAdd","_Transaction_instances","_type","_to","_nonce","_gasLimit","_gasPrice","_maxPriorityFeePerGas","_maxFeePerGas","_chainId","_sig","_accessList","_maxFeePerBlobGas","_blobVersionedHashes","_kzg","_blobs","__privateSet","__privateGet","versionedHashes","blob","isBytesLike","padded","commit","proof","kzg","__privateMethod","getSerialized_fn","types","hasGasPrice","hasFee","hasAccessList","hasBlob","signed","sidecar","Transaction"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}